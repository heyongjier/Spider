1. 进程是计算机运行程序的一个基本资源单位。除非一些破坏性程序、病毒、杀毒软件等，不同进程之间默认是分隔的。  
而线程则是组成进程的，计算机执行的基本单位。

&nbsp;

2. 在爬虫中可以引入多线程进行并行工作，提高工作效率。一个多线程的简单示例：
    ```
    # 导入多线程包
    from threading import Thread

    def worker(): # 定义一个子线程工作的函数
        print("worker started \n")
        for i in range(2000):
            print(f"子线程：{i}")


    if __name__ == '__main__': # __main__表示的是该程序的主进程的主线程

    t = Thread(target=worker) #定义一个子线程
    t.start()
    print("子线程启动 \n")
    print("主线程启动 \n")
    for i in range(2000):
        print(f"主线程：{i}")
    ```  

    我们可以通过结果明显的看到，子线程和主线程纯在一个资源竞争的过程，两个线程在同一进程结束都可以完成对应的工作：
    ```
    worker started 
    子线程启动 

    主线程启动 

    主线程：0
    主线程：1
    主线程：2
    主线程：3
    主线程：4
    主线程：5
    主线程：6
    主线程：7
    子线程：0
    主线程：8

    子线程：1主线程：9
    ........................
    子线程：1982主线程：1997

    子线程：1983主线程：1998

    子线程：1984主线程：1999

    子线程：1985
    .........
    子线程：1998
    子线程：1999
    ```
    CPU通过时钟进行调度，对未执行的线程进行堵塞

&nbsp;

3. 对于一个爬虫而言，大量的数据爬取，应当是采用越多的线程效率越高，但我们也要注意到多线程对于系统资源的占用，要平衡线程数量和资源占用的关系，这个之后就可以考虑使用线程池：
    ```
    from concurrent.futures import ThreadPoolExecutor

    def worker(ThreadName):
        for i in range(10):
            print(ThreadName)


    if __name__ == '__main__':
        with ThreadPoolExecutor(max_workets) as t: 
        #指定最大的线程池数，定义：max_workers = min(32, (os.process_cpu_count() or 1) + 4),默认是CPU核数＋4或者32
            for i in range(10):
                t.submit(worker, ThreadName=f"Thread-{i}")
    ```
结果：  

    ........
    Thread-4
    Thread-8Thread-9
    Thread-9

    Thread-6

    Thread-4Thread-7
    Thread-9


    Thread-9Thread-4
    Thread-9Thread-7Thread-6
    Thread-8
    .........


上述程序的任务实际上是10个，然后每个线程完成的任务是重复`print`100次，并不是10000个任务同时进行。

&nbsp;

4. 在爬虫中，对于多线程而言，代表的往往是一类相似的任务，例如下载、爬取目录等操作；而对于多进程，则是相对于并行执行隔离的任务。由于Python的全局解释锁的问题，导致多线程无法使用多核CPU，所以使用多核CPU爬取可以考虑使用多进程，但是资源消耗非常大，一般并不采用