# 对象
对象在JS中实际上就是一堆键值对，是无序的符合数据集合。其中的键名和键值通过冒号进行连接。
## 1.对象的定义
  对象的所有键名都是字符串，在ES6中引入了Symbol值也可以作为键名，所以加不加引号都可以。对于obj而言，即使在命名时使用了数字，实际上也会自动转化为字符串。  
  对象的键名实际上就是属性，如果一个属性的值为函数，则称为这个属性为方法，同样也可以像函数一样被调用：
  '''
    var obj = {
        p : function() {
            console.log("hello");
        }
    };  

    obj.p(); // "hello"
  '''  
  一个对象的属性是可以动态进行创建的，并不只能在声明时创建对象的所有的属性的值，其中当一个属性的值指向另外一个对象，这样就会形成链式调用：
  '''
    var o1 = {};
    var o2 = { foo: 42 };
    o1.bar = o2;
    console.log(o1.bar.foo); // 42
  '''

## 2.对象的引用
    在JS中，对象对应的变量名实际上也是指向一块内存，也就是说当两个声明上的对象变量名指向同一个对象，对其中一个进行操作同样也会影响到另一个实际上也指向该块内存变量名不同的对象：
    '''
        var o1 = {};
        var o2 = { foo: 42 };
        o1.bar = o2;
        console.log(o1.bar.foo); // 42
    '''
    此外，还需要注意的是，{}大括号括起来的内容，里面到底是一个表达式还是代码块，这个是有歧义的，所以如果是要是解释为一个对象的定义，一定要保证大括号是一个表达式，这个时候就需要用()将其括起来，这样就是表达式而不是代码块：
    '''
        {console.log(123)}  //123
        ({console.log(123)}) //此处为一个表达式，并不能执行，报错
    '''
## 3. 对象的属性
- 属性的读取
    两种方法：使用点运算符；使用方括号运算符。
- 属性的赋值
    上述读取的两种方法复制。
-  属性的查看
    查看一个对象本身的所有属性，可以使用'Object.keys()'方法：
    '''
        var obj = {
            a: 1,
            b: 2,
            c: 3
        };

        var obj_keys = Object.keys(obj);
        console.log(obj_keys); //  ['a', 'b', 'c']

        var obj_values = Object.values(obj);
        console.log(obj_values); //  [1, 2, 3]
    '''
- 属性的删除
    可以直接使用delete命令,执行成功后会返回true，尤其注意，即使要delete一个并不存在的属性，并不会报错，而且也会返回true，只有该属性存在且不能删除的情况(例如Object.definProperty方法)才会返回false。同时delete也无法删除继承的属性(但会返回true)：
    '''
        var obj = { p: 1 };
        Object.keys(obj) // ["p"]

        delete obj.p // true
        obj.p // undefined
        Object.keys(obj) // []
    '''
- 判断属性是否存在
    使用in运算符，左边是要判断的键名，右边是要判断的对象，如果存在则返回true。
## 3. with语句
    操作同一个对象的多个属性值时，提供简便可读的操作：
    '''
        with (对象) {
            语句;
        }
    '''
    使用with语句会造成变量的作用域的混乱，通常情况下并不建议使用with。

&ensp;

# 函数

## 1. 函数的声明
- function命令
    使用function声明的代码块就是一个函数。

- 函数表达式
    还可以采用变量赋值的写法：
    '''
    var print = function(s) {
        console.log(s);
    };
    '''
    采用上述方式实际上函数名右边一定要跟一个匿名函数表达式，此时如果function后还加一个函数名，这个函数名在函数体外是没有任何意义的，也不可能通过这个function后面的函数名去调用这个函数。但实际上也经常采用这种方式，因为可以在函数内部调用自身；在调试过程中调用栈将会显示一个函数名而不是匿名函数。

- Function构造函数
    可以传递任何数量的参数给Function构造函数，其中只有最后一个参数会被当做函数体，如果只传递了一项数据，那就是函数体：
    '''
        var add = new Function(
        'x',
        'y',
        'return x + y'
        );

        // 等同于
        function add(x, y) {
        return x + y;
        }
    '''

- 函数重复声明
    重复声明的函数，后面的声明就会覆盖前面的声明。由于函数名的提升前一次声明在任何时候都是无效的。
- 调用函数直接在函数体或者函数名之后直接加一个圆括号，传递参数就可以直接调用执行该函数。
- 函数体内部的return语句表示返回。在JS中遇到return会停止后续函数体的执行，返回对应的值。如果一个函数的函数体并没有return语句，那么就可以说返回了一个undefined。
- 函数调用自身就是递归。

- 在JS中，实际上是将一个具体的函数视作一个值，与其他包括数值、字符串等都是相同的。同理，凡是能用到值的地方，函数一样也可以，传递参数、赋值给对象的某个属性等等。处理函数可以被执行外，别无任何差别。
## 2. 函数名的提升
- 在JS中实际上是将函数名视作变量名。也就是说，使用function声明一个函数，整个函数回想变量的声明一样，提升到代码的头部，也就是说先调用再定义的代码书写顺序再执行的逻辑上并不会报错。
- 但要注意，使用赋值语句就不能考虑函数名的提升，因为这就是一个变量名的声明过程，只不过赋值的是一个函数体。此时调用后声明的函数会出错。
- 还要注意函数的重复声明会覆盖，也就造成了：
    '''
        var f = function () {
            console.log('1');
        }

        function f() {
            console.log('2');
        };

        f() //1
    '''
## 3. 函数的属性和方法
- name属性：返回函数的名字
    但是要注意，函数表达式声明时，function后如果跟了所谓的函数名，将返回该函数名，否则的话会返回变量定义的函数名。
- length属性：返回函数预期传入的参数个数。
- toString属性：返回一个字符串，内容是函数的源码。对于JS中的原生的函数，toString()方法返回function (){[native code]}。
## 4. 函数作用域
作用域是变量的存在范围，在ES5中，只有全局作用域和函数作用域。在ES6中存在块级作用域。
- 函数内部的变量提升
    var声明的变量在什么位置，都会提升至函数体内的头部：
    '''
        function foo(x) {
        if (x > 100) {
            var tmp = x - 100;
        }
        }

        // 等同于
        function foo(x) {
        var tmp;
        if (x > 100) {
            tmp = x - 100;
        };
        }
    '''
- 函数本身的作用域
在JS中函数本身也是一个值，作用域与变量一样，就是声明所在的作用域，与其运行时的作用域无关：
    '''
        var a = 1;
        var x = function () {
        console.log(a);
        };

        function f() {
        var a = 2;
        x();
        }

        f() // 1
    '''
    上述代码，x函数的声明绑定在外侧，他的作用域就绑定在外层，在取值时也是外层取值。所以函数的定义域一定要看声明时的作用域而不是调用时的作用域。
## 5 参数
    对于函数的参数而言，并不是必须的，可以省略参数，同时即使传递比声明的参数要多也不会报错，而是保留靠后的参数。同名参数则取最后出现的值  
    同时需要注意，如果是传值参数则不会影响作用域外的变量，但如果是传址参数（数组、对象、其他函数等）则会影响到原始值。
- argument对象
    在JS中，使用arguments对象，包含函数运行的所有参数。只有在函数体内部才可以使用该对象。使用`argument.length`方法可以判断在函数调用时到底需要几个参数。
## 6 闭包
    在JS中存在一种链式作用域的结构：子对象会一层一层的向上寻找每个父对象的变量，而父对象是无法读取子对象内部的变量。  
    也就是说：
    '''
        var f1= function () {
            var n = 1;
            function f2() {
                console.log(n);
            }
            return f2;
        }

        var result = f1();
        result(); // 1
    '''
    此时f2作为f1的子对象，是可以找到对应的父对象的变量，同时将其返回。此时f2就是一个闭包函数：定义在函数内部的函数。构建一个函数内与外连接的桥梁。
- 使用闭包函数可以让外部函数读取内部的变量
- 使用闭包函数可以让这些变量时钟保持在内存中，同时可以对变量进行修改、赋值等，这些是直接return该变量做不到的。
- 使用闭包还可以封装对象的私有属性和私有方法。
## 7. 立即嗲用的函数表达式
如果function关键字出现在行首，一律解释成语句。因此，引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。

函数定义后立即调用的解决方法，就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。

通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。
## 8 eval命令