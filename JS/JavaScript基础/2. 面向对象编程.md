# 对象与实例对象
## 1. 对象概念
OOP中，每个对象是单个实物的抽象，同时，对象也是一个封装了属性和方法的容器。  
面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。
## 2. 构造函数
不同于其他编程语言，在JS中，并不基于类创建实例对象，而是借助与构造函数(constructor)和原型链(prototype)。构造函数作为对象的模板，是专门用来生成实例对象的函数，描述实例对象的基本结构。  
构造函数有两个特点：内部使用this关键字，表示要生成的对象实例；生成对象时使用new命令。此外，一般构造函数与普通函数区别，第一个字母大写。
## 3. new
- new命令的作用就是执行构造函数，返回一个实例对象：
    '''
        var Vehice = function () {
            this.price = 1000;
        };

        var v = new Vehice();
        console.log(v.price); // 1000
    '''
    构造函数也可以接受带参数也可以不带；同时由于new命令的作用就是执行后面的构造函数，所以函数名后可以带可以不带括号
- new命令原理：
    1. 创建一个空对象作为要返回的实例对象。
    2. 将这个空对象的原型指向构造函数的prototype属性
    3. 将空对象赋值给函数内部的this关键字
    4. 开始执行构造函数内部的代码
    在构造函数的执行结束后，如果有return语句，且return语句后跟着的是一个对象则返回return后的对象，否则其他类型的话只会返回this对应的对象。  
    另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。

# this关键字
## 1. this关键字含义
首先要记住this关键字无论是什么用途，作用共同点就是总返回一个对象。同时，简单来说，`this.property`就是表示了property属性当前所在的对象。  
this后属性所指向的属性可能会动态赋值给另外的对象等，this所指代的对象也会动态变化：
    '''
        var A = {
            name: '张三',
            describe: function () {
                return '姓名：'+ this.name;
            }
        };

        var name = '李四';
        var f = A.describe;
        f() // "姓名：李四"
    '''
## this实质
JS中之所以有this设置，和内存中的数据结构有关。  
对象存储在内存中，然后实例对象会有一个变量指向该地址。但对于对象的方法而言，也就是说当对象的属性值是一个函数时，该函数可能会被对象调用执行对象方法，也可能全局调用当作一个函数执行，此时函数内部的变量等需要根据其运行环境和上下文确定，所以就需要一个this的出现，在函数体内部指代当前函数的运行环境。
```
    var f = function () {
        console.log(x);
    }

    var x = 1;
    var obj = {
        f: f,
        x: 2,
    };

    // 单独执行
    f() // 1

    // obj 环境执行
    obj.f() // 1
```  

```
    var f = function () {
        console.log(this.x);
    }

    var x = 1;
    var obj = {
        f: f,
        x: 2,
    };

    // 单独执行
    f() // 1

    // obj 环境执行
    obj.f() // 2
```

## 3. this使用场合
- 全局环境
 全局环境下，使用this指代的就是顶层对象window。  
- 构造函数
 构造函数中的this指代的是实例对象。
- 对象的方法
 对象的方法中包含this，此时this指向的是方法运行时所在的对象。对象之间的相互赋值会改变this的指向：
    ```
    var obj ={
        foo: function () {
            console.log(this);
        }
    };

    obj.foo() // obj

    // 情况一
    (obj.foo = obj.foo)() // window
    // 情况二
    (false || obj.foo)() // window
    // 情况三
    (1, obj  foo)() // window
    ```  
 如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层:
    ```
        var a = {
            p: 'Hello',
            b: {
                m: function() {
                console.log(this.p);
                }
            }
        };

        a.b.m() // undefined this指向a.b而不是a
    ```
## 4. this的绑定
this的动态切换有时也会给编程带来困难和模糊，需要将this固定下来，提供了call、apply、bind三种方法：
- Function。prototype.call()
 可以指定函数内部的this的指向，在所指定的作用域中调用该函数。
    ```
        var obj = {};

        var f = function () {
            return this;
        };

        f() === window // true
        f.call(obj) === obj // true
    ```  
 call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。还可以传入多个参数，除第一个外剩下的都是函数运行时要传递的参数。
- Function.prorotype.apply()
 apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数.
- Funciton。prototype.bind()
 用于将函数体内的this绑定到某个对象，然后返回一个新函数:
    ```
        var counter = {
        count: 0,
        inc: function () {
            this.count++;
            }
        };

        var func = counter.inc.bind(counter);
        func();
        counter.count // 1
    ```
 如果bind()方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（浏览器为window）。