1. 在js中，函数的在取参的过程实际上是通过一个叫arguments数据进行取值，这也就造成了在定义过程中的形参形式和数量可以和实参完全不对等，因为最终还是从数组取所有参数。  

在js
中，函数实际上就是一个赋予特殊值的变量，所以函数名实际上就是变量名，可以将其他变量赋予一个函数的值：`var fn = function() {}`,同时函数也支持嵌套逻辑:
```
fubction fn(){
    return functino(){
        console.log()
    }
}

fn()();  //这就完成了函数的嵌套运行，此时执行的是fn()内的function，换而言之，对于js而言，只要带有()就可以看作一次函数的运行

(function(){
    console.log()
}())  //自运行函数，执行到这里，前半部分定义一个函数，加上()直接运行。
还可以添加一些运算符号：!function(){}(); -function(){}(); ~function(){}();
```

arr.forEach(function(e,t)) 与arr.map(function(e,t)),都是将数组中所有的数据执行function，其中e和t都算只读数据，是不可以更改的对于map和forEach函数永远只做遍历:
```
const arr = [1, 2, 3];
const result = arr.forEach(function(e, t) {
  console.log(`索引 ${t}: 值 ${e}`);
  return e * 2; // 不会被保存！
});
/*
*索引 0: 值 1
*索引 1: 值 2
*索引 2: 值 3
*/
console.log(result); // undefined

const arr = [1, 2, 3];
const result = arr.map(function(e, t) {
  return e * 2;
});

console.log(result); // [2, 4, 6]

```

&ensp;

2. 在JS中，函数的执行首先会对变量进行声明，预防内存溢出等错误。  
例如：  
    ```
        function fn(){
            console.log(a);  //undefined
            var a = 10;
        }
    ```  

    在执行过程中，JS会首先执行`var a;`声明一个变量，原本的声明＋赋值就会变成：`a = 10`。这就是变量的提升。  

    在程序设计中，变量的提升实际上并不方便，所以在ES6标准中，使用`let`来声明变量，防止变量提升情况发生。此外`const`也可以，但是定义的是常量，不可以更改。同时，这两个关键字声明的变量在同一个作用域中是不可以重复声明的：
    ```
    // 这样使用let和const是错误的
    // let a = 1;
    // let a = 2;
    // let a = 3;
    // let a = 4;

    ```
  
&ensp;

3.  注意函数和变量的作用域。  
    在JS中，可以window代表全局，也就是说可以使用window赋值一个全局的函数或者变量：  
    ```
    fuction gn(){
        var fn = function(){
            var a = 10;
            console.log(a);
        }

        window.fn = fn;
    }

    fn();   //这样就可以实现单独调用域内的函数
    ```  

&ensp;

4. 闭包就是函数能够“记住”并访问它定义时所在的词法作用域（scope），即使函数在该作用域之外被调用。
    ```
    function outer() {
    let count = 0; // 外部函数的局部变量

    function inner() {
        count++; // 内部函数访问外部函数的变量
        console.log(count);
    }

    return inner; // 返回内部函数
    }

    const counter = outer(); // outer 执行后返回 inner
    counter(); // 输出 1
    counter(); // 输出 2
    counter(); // 输出 3

    // 当 outer() 执行完毕后，按理说它的局部变量 count 应该被销毁。

    // 但由于返回的 inner 函数仍然引用着 count，JS 引擎不会回收它。

    // inner 就形成了一个闭包，可以持续访问并修改 count。
    ```

&ensp;

5. 定时器：
    - setTimeout，xxxms后函数开始执行：
    ```
    setTimeout(function(){
        consle.log("helllo")
    },1000)
    ```
    使用clearTimeout(序号);可以清除已经有的定时器。
    - setInterval，xxms后运行一次函数。常用于检测环境，循环发送，debugger断点、循环运行等  
    clearInterval可以清除。 
    &ensp;
    在一些反爬策略中，会使用诸如`setInterval(function(){debugger},100)`反复执行断点来防止打开调试工具，这时除了可以使用`右键选中，到此处不暂停`之外，推荐直接对setInterval进行赋值，通过hook逻辑，使其为空:
    ```
    var _setInterval = setInterval;
    setInterval = function(){};
    setInterval = _setInterval;
    ```
    

    定时器是非阻塞的，在等待的过程中，其他的逻辑会正常进行运行。

&ensp;

6. eval函数，将字符串当作正常的代码表达式进行运行。  
   在有些eval函数中，可能包含许多复杂的表达式，但最终一定是一个字符串。也就是说eval中的是复杂的字符串构造。我们可以将其中的内容复制出来，通过()构造一个自运行函数，在控制台查看一下结果
