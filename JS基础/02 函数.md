1. 在js中，函数的在取参的过程实际上是通过一个叫arguments数据进行取值，这也就造成了在定义过程中的形参形式和数量可以和实参完全不对等，因为最终还是从数组取所有参数。  

在js
中，函数实际上就是一个赋予特殊值的变量，所以函数名实际上就是变量名，可以将其他变量赋予一个函数的值：`var fn = function() {}`,同时函数也支持嵌套逻辑:
```
fubction fn(){
    return functino(){
        console.log()
    }
}

fn()();  //这就完成了函数的嵌套运行，此时执行的是fn()内的function，换而言之，对于js而言，只要带有()就可以看作一次函数的运行

(function(){
    console.log()
}())  //自运行函数，执行到这里，前半部分定义一个函数，加上()直接运行。
还可以添加一些运算符号：!function(){}(); -function(){}(); ~function(){}();
```

arr.forEach(function(e,t)) 与arr.map(function(e,t)),都是将数组中所有的数据执行function，其中e和t都算只读数据，是不可以更改的对于map和forEach函数永远只做遍历:
```
const arr = [1, 2, 3];
const result = arr.forEach(function(e, t) {
  console.log(`索引 ${t}: 值 ${e}`);
  return e * 2; // 不会被保存！
});
/*
*索引 0: 值 1
*索引 1: 值 2
*索引 2: 值 3
*/
console.log(result); // undefined

const arr = [1, 2, 3];
const result = arr.map(function(e, t) {
  return e * 2;
});

console.log(result); // [2, 4, 6]

```

&ensp;

2. 在JS中，函数的执行首先会对变量进行声明，预防内存溢出等错误。  
例如：  
    ```
        function fn(){
            console.log(a);  //undefined
            var a = 10;
        }
    ```  

    在执行过程中，JS会首先执行`var a;`声明一个变量，原本的声明＋赋值就会变成：`a = 10`。这就是变量的提升。  

    在程序设计中，变量的提升实际上并不方便，所以在ES6标准中，使用`let`来声明变量，防止变量提升情况发生。此外`const`也可以，但是定义的是常量，不可以更改。同时，这两个关键字声明的变量在同一个作用域中是不可以重复声明的：
    ```
    // 这样使用let和const是错误的
    // let a = 1;
    // let a = 2;
    // let a = 3;
    // let a = 4;

    ```
  
&ensp;

3.  注意函数和变量的作用域。  
    在JS中，可以window代表全局，也就是说可以使用window赋值一个全局的函数或者变量：  
    ```
    fuction gn(){
        var fn = function(){
            var a = 10;
            console.log(a);
        }

        window.fn = fn;
    }

    fn();   //这样就可以实现单独调用域内的函数
    ```  

&ensp;

4. 闭包就是函数能够“记住”并访问它定义时所在的词法作用域（scope），即使函数在该作用域之外被调用。
    ```
    function outer() {
    let count = 0; // 外部函数的局部变量

    function inner() {
        count++; // 内部函数访问外部函数的变量
        console.log(count);
    }

    return inner; // 返回内部函数
    }

    const counter = outer(); // outer 执行后返回 inner
    counter(); // 输出 1
    counter(); // 输出 2
    counter(); // 输出 3

    // 当 outer() 执行完毕后，按理说它的局部变量 count 应该被销毁。

    // 但由于返回的 inner 函数仍然引用着 count，JS 引擎不会回收它。

    // inner 就形成了一个闭包，可以持续访问并修改 count。
    ```

&ensp;

5. 定时器：
    - setTimeout，xxxms后函数开始执行：
    ```
    setTimeout(function(){
        consle.log("helllo")
    },1000)
    ```
    使用clearTimeout(序号);可以清除已经有的定时器。
    - setInterval，xxms后运行一次函数。常用于检测环境，循环发送，debugger断点、循环运行等  
    clearInterval可以清除。 
    &ensp;
    在一些反爬策略中，会使用诸如`setInterval(function(){debugger},100)`反复执行断点来防止打开调试工具，这时除了可以使用`右键选中，到此处不暂停`之外，推荐直接对setInterval进行赋值，通过hook逻辑，使其为空:
    ```
    var _setInterval = setInterval;
    setInterval = function(){};
    setInterval = _setInterval;
    ```
    

    定时器是非阻塞的，在等待的过程中，其他的逻辑会正常进行运行。

&ensp;

6. eval函数，将字符串当作正常的代码表达式进行运行。  
   在有些eval函数中，可能包含许多复杂的表达式，但最终一定是一个字符串。也就是说eval中的是复杂的字符串构造。我们可以将其中的内容复制出来，通过()构造一个自运行函数，在控制台查看一下结果.  

&ensp;

7. 在JS中，实际上全局都是一个Window，Window下包含有JS的所有对象等。尤其注意location，location就是浏览器的信息。当运行JS发现有location时，直接去浏览器获取该location就可以。`console.log(window.location)`，在编辑器中运行是undefined，在浏览器运行才可以出对应的信息。同样逻辑的还有navigator，document等。

&ensp;

8. ES6中还有箭头函数，`var fn = () => {}`，当参数只有一个是，（）可以省略。  如果和函数体只有一个表达式，大括号可以省略，返回值也可以省略：`var fn = (a,b) => a + b;`

&ensp;

9. 如果想要保存web的数据，只借助cookie的话，每次请求都会请求携带cookie值。并不方便高效。所以在JS中可以通过storage进行存储：
    - localstorage：本地存储空间，浏览器本地保存，即使再次打开浏览器该数据依旧会有。
    - sessionstorage：会话存储空间，只在会话请求中存储信息，关闭浏览器后会清除sessionstorage。

   有时候在逆向过程中，网站的逻辑可能会取用本地存储localstorage保存的加密的密文，这样在请求过程中就不会进行加密运算，无法查看加密的逻辑。所以在逆向之前要清除application中的所有存储空间和cookie的数据。

&ensp;

10. Promise 的 .then() 和 .catch() 是 JavaScript 中处理异步逻辑的核心机制.返回一个promise对象，用户处理异步逻辑:
```
    someAsyncFunction()
    .then(result => {
        console.log('成功：', result)
    })
    .catch(error => {
        console.error('失败：', error)
    })
```

执行的流程：

    - 调用 someAsyncFunction()，它返回一个 Promise。

    - 如果这个 Promise 成功（resolved），就进入 .then()。

    - 如果这个 Promise 失败（rejected），就进入 .catch()。

链式调用逻辑
```
    doSomething()
    .then(result1 => {
        return doSomethingElse(result1)
    })
    .then(result2 => {
        return doThirdThing(result2)
    })
    .catch(error => {
        console.error('出错了：', error)
    })
```

逻辑说明：

- 每个 .then() 都会返回一个新的 Promise。

- 如果 .then() 里的函数 正常返回一个值，这个值会传递给下一个 .then()。

- 如果 .then() 里的函数 抛出错误 或返回一个 拒绝的 Promise，就会跳过后续 .then()，进入最近的 .catch()。

错误传递机制
```
    Promise.resolve()
    .then(() => {
        throw new Error('这里出错了')
    })
    .then(() => {
        console.log('这不会执行')
    })
    .catch(err => {
        console.log('被捕获：', err.message)
    })
```

 结果输出：

被捕获： 这里出错了


只要在链条中某一处抛错（或返回 reject），后续的 .then() 都会被跳过，直接进入 .catch()。

.catch() 后还能继续 .then()
```
    doSomething()
    .catch(err => {
        console.warn('错误已处理：', err)
        return '默认值'
    })
    .then(value => {
        console.log('继续执行：', value)
    })
```

 逻辑：

- .catch() 处理错误后返回一个新值；

- 该值会传递给下一个 .then()；

- 链条会继续执行，不会中断。

&ensp;

11. JSON.parse()   JSON.stringify(),JS中JSON对象与字符串相互转化的函数。所有的JS加密都要基于字符串，所以加密的逻辑一定会有对象->字符串->密文，解析则是相反，所以这两个函数是加密解密的关键。