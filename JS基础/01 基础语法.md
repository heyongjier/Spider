1. js中的if语句是可以简写成一行的，js中并没有严格的缩进语法规则，此时紧跟的后面的第一个表达式就是对应的判断执行语句：
    ```
    var i = 10;
    if (i>1) console.log("大于1"); else if XXXX; else xxxx;
    ```

&ensp;

2. 在js中的switch逻辑，语法规则是存在穿透问题的，即匹配到对应的case后，后续的case判断不会执行，而是当作判断成功全部执行后续的语句。如果想取消这种穿透现象对执行语句的影响，可以对每个case后的执行语句后加一个`break;`

&ensp;

3. 在js的while循环中，还可以写做do-while,先执行再判断：
    ```
    var i = 0;
    do {
        i = i + 1;
    } while (i < 10)
    ```  
    而在for循环中，则写作：
    ```
    for (循环变量初始化,条件判断,改变初始变量) {
        循环体
    }

    在设计过程中就保证了：
        表达式1：首先运行并且只循行一次；
        表达式2：检测是否为真，如果是就执行循环体；
        表达式3：循环体执行结束后，自动执行该内容

    上述的表达式可以省略部分，对应的表达式不在for执行，但只要有定义有意义就可以
    ```

&ensp;

4. 在js中，对象对标的是类似python的dict,其中key如果是字符串可以省略引号：
    ```
    var obj = {
        key1 = "value1",
        key2 = "value2"
    }

    取值可以：obj.key1或者obj['key1']

    ```

&ensp;

5. 在js中，函数的在取参的过程实际上是通过一个叫arguments数据进行取值，这也就造成了在定义过程中的形参形式和数量可以和实参完全不对等，因为最终还是从数组取所有参数。  

在js
中，函数实际上就是一个赋予特殊值的变量，所以函数名实际上就是变量名，可以将其他变量赋予一个函数的值：`var fn = function() {}`,同时函数也支持嵌套逻辑:
```
fubction fn(){
    return functino(){
        console.log()
    }
}

fn()();  //这就完成了函数的嵌套运行，此时执行的是fn()内的function，换而言之，对于js而言，只要带有()就可以看作一次函数的运行

(function(){
    console.log()
}())  //自运行函数，执行到这里，前半部分定义一个函数，加上()直接运行。
还可以添加一些运算符号：!function(){}(); -function(){}(); ~function(){}();
```

arr.forEach(function(e,t)) 与arr.map(function(e,t)),都是将数组中所有的数据执行function，其中e和t都算只读数据，是不可以更改的对于map和forEach函数永远只做遍历:
```
const arr = [1, 2, 3];
const result = arr.forEach(function(e, t) {
  console.log(`索引 ${t}: 值 ${e}`);
  return e * 2; // 不会被保存！
});
/*
*索引 0: 值 1
*索引 1: 值 2
*索引 2: 值 3
*/
console.log(result); // undefined

const arr = [1, 2, 3];
const result = arr.map(function(e, t) {
  return e * 2;
});

console.log(result); // [2, 4, 6]

```