1. 在JS中，function可以作为普通函数，也可以作用contructor构造函数来构造对象。此时函数名一般大写：
```
    function ClassTest(name,value) {
        this.name = name;
        this.value = value;
    }

    var c1 = new ClassTest("xiaoming","xxx");   //调用执行要new这是区别与普通函数的重要标志
```

&ensp;

2. 在JS中向类内添加方法，直接使用构造函数，嵌套一个`this.xx.fucntion()`其实是不合理的。构造函数本质上就是对类对象进行一个初始化，这样所有的对象都会带这个function，会造成内存的重复占用，也不符合面向对象的思想，调用的本质上也不是类函数。  
但在js中，所有的函数都会自带一个prototype的属性（原型），所以去定义方法函数就可以使用这个属性：

```
    function ClassTest(name,value) {
        this.name = name;
        this.value = value;
    }

    ClassTest.prototype.xx = function(){}    //这样是对ClassTest类添加方法

```

&ensp;

3. 在一个对象中，会存在`p1.__proto__`,这个指向的是一个原型对象。在执行时，如果是对象本身就有的方法，则直接执行，否则去查找原型对象，再没有就去原型对象的原型对象。。。。最终指向Object原型对象。  
上述就是JS对象的原型链。所以所有的对象可以使用Object的所有方法。JS中所有的对象也都是Object的实例类型。

&ensp;

4. 在JS中所有的东西都是对象，所有的对象都有对应的__proto__。函数也不例外，是Function的对象。

&ensp;

5. 所有的函数都有call和apply方法。  
- call可以调用函数，在普通函数调用中，是不是用call方法其实都一样。但在类调用方法的使用，使用普通的调用`p.do()`实际上在类方法中this指定该对象调用。`p.do.call()`则会将其视为一个普通的函数调用，普通函数调用this默认是指向JS的window的。  
同时call()可以指定参数`call(this指定的对象，函数本身需要的其他参数)`,用于改变函数指向的对象，即`Person.prototype.do.call(p)`这个等价于 `p.do()`。使用框架设计时，call更具有优势，可以调用不同的对象方法。  

- apply的逻辑和call是一样的。  
  call传递其他参数是，后续的参数几个都可以，但是apply只能两个参数，`apply(this指定的对象，[参数1，参数2])`。

&ensp;

6. hook，最重要的应用就是在大规模的代码中选中指定的函数、代码逻辑等。例如在逆向过程中通过JSON.parse()和JSON.stringify()找到加解密的JS。
```
    var _变量 =  被hook的函数;
    被hook的函数 = function(根据原来的函数确定参数){
        debugger; //其他逻辑等
        return _变量(根据原来的函数确定参数);
    }
```

hook还可以获取对象的属性值，例如去抓取cookie等：
```
Object.defineProperty(document,"cookie" {
            set() {
                debugger;
            },

            get() {
                debugger;
            }
        });

```